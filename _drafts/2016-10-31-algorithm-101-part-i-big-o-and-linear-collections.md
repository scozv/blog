---
layout: post
title: "Algorithm 101 Part I, Big O and Linear Collections"
description: ""
category: "algo"
tags: ["algorithm"]
lang: "zh"
---
{% include JB/setup %}

# 摘要
{:.no_toc}

<!--more-->

* Will be replaced with the ToC, excluding the "Contents" header
{:toc}

# 算法无处不在

如果我们想解决如下的问题，我们需要想出一个可行的方法：

* 给定一个数组和一个整数，找出两个数、其和等于该整数
* 找出一段时间代码中，哪次提交影响了程序？
* 判断两个人之间是否能通过朋友关联起来
* 警察抓来几个嫌疑人，如果只有一个人说的是真话，谁的嫌疑最大？
* 快速地统计出频次最高的前五个单词
* 给定一个文件，快速定位到某个文件夹

诸如此类。

通常而言，我们认为，我们选用的这个方法，具备如下特征：

* 有输入、输出
* 明确可执行，就是通过语言、或者手写计算能够表述，并实现预期的结果（我们在Dijstra最短路径中会更加清楚地看到）
* 有限时间内可执行

这里“有限时间”就是我们本文要讲的"Big O"。

# Two Sum问题

问题描述如下。

* 输入：一个数组`xs`，一个整数`T`
* 输出：数组`xs`中的两个元素`x`、`y`，满足，$$ x + y  = T $$

仅上面的条件，还会带来一些极端的情况，比如：

* 数组为空，或者找不到这样的两个元素
* 其它（请作为练习题）

## 最直接的办法

我们可以枚举`xs`中所有的二元序列 $$(x, y)$$，然后遍历这些枚举值，看看哪一组满足
$$x+y=T$$。

{% highlight JavaScript linenos%}
for (i=0;i<len(xs);i++) {
  for (j=i;j<len(xs);j++) {
    if (xs[i] + xs[j] == T)
      return [xs[i], xs[j]]
  }
}
{% endhighlight %}

## 运行时间估计

我们假定加法运算和等号比较运算的完成时间为$$t$$，我们容易得出，上述计算的完成时间：

$$T(n)=(n-1)t + (n-2)t + \ldots + 2t + t = t\cdot \sum_{i=1}^{n-1} i = t\cdot \frac{(n-1+1)(n-1)}{2}$$

如果`for`循化前后还有一些准备工作的话，我们加上一个常数项：

$$T(n)=\frac{n(n-1)}{2}t + C=\frac{t}{2}n^2 - \frac{t}{2}n + C$$

首先给出一个结论，我们说：

$$T(n) = O(n^2)$$

# Big O 和 Big Theta

## Big O 的正式定义


下面给出Big O的正式定义。

当我们说，随着 $$x \rightarrow \infty $$，若：

$$f(x) = O(g(x))$$

则表示，当且仅当：

$$\exists M > 0, x_0 > 0, \forall x \geq x_0 \rightarrow |f(x)| \leq M |g(x)|$$

## Big O的几个证明题

* 证明  $$T(n)=O(n^2)$$
* 证明  $$T(n)=O(\lambda_0 n^2) \Rightarrow T(n)=O(n^2)$$
* 证明  $$T(n)=O(n^2), G(n)=O(n \ln n) \Rightarrow \exists M > 0, n_0 > 0, \forall n \geq n_0 \rightarrow T(n) \geq M \cdot G(n)$$

需要注意的是，第三个证明题，实际上是不成立的。

我们来看看第三个证明题的证明过程，可以根据定义得到：

...

我们可以看到，在Big O定义下面，无法建立起不等式的关联关系。

## Big Theta的正式定义

Big O定义了函数的上限，Big Theta定义了函数的上下限。

下面给出Big Theta的正式定义。



## 算法分析中的Big O

算法分析中的Big O，实际上，是上下限的分析。

## 几个常见的Big O的差异

# Two Sum问题的改进算法

Two Sum问题的改进有两个思路：

* 第一个`for`循环找`a`，第二`for`循化找`b`。所以我们得降低我们“找”这个动作复杂度；
* 另一种思路是，我们能从数组的两头查看，并找到满足条件的两个整数

给出一个，源代码，我们来看看它的复杂度。

## 二分查找

二分查找有一个前提条件，并且还有一个注意事项（参考[Java Bug 6412541](http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6412541)）。

## Hash查找

Hash我们会在第三节课讲，它的目的是把一个空间缩小，并映射到另外一各个空间。　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　
## 排序后查找

排序我们会在第二部分讲，我们需要知道的是，通常基于比较的排序，时间复杂度为$$O(n \ln n)`$$

# 线性数据结构

线性数据结构，基本上是算法和数据结构的基础，数组的存放、排序，图的表示都是以线性数据结构为基础的。

## 线性数据结构的常见操作

如下操作，会在所有的线性结构中出现。

* 创建一个空结构
* 添加一个元素、在尾部、在头部和在指定的位置
* 删除一个元素、在尾部、在头部和在指定的位置
* 找到一个指定的元素
* 序列反转
* 序列遍历

## 一些常见的线性结构的实现

下面用图示的方式，解释不同线性结构的。
需要注意的是，涉及到指针的操作，需要留意

* 指针的动态变化
* 头指针的维护
* 尾部指针的维护

常见的线性结构为：

*  数组
*  单向链表
*  双向链表
*  环路
*  队列
*  堆栈
*  并查集
*  堆（优先队列）

二元堆是一个可以用线性列表表示的树状结构，在Dijkstra最短路径算法中可以显著地提高效率。
