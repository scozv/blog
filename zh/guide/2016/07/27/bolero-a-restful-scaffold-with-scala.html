

<!DOCTYPE html>
<html lang="en-us">

  <head>
  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'PT+Sans::latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })(); </script>

  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <meta http-equiv="Content-Language" content="zh"><link rel="alternate" i18n="en" href="https://scozv.github.io/blog/guide/2016/07/27/bolero-a-restful-scaffold-with-scala" />
<link rel="alternate" i18n="zh" href="https://scozv.github.io/blog/zh/guide/2016/07/27/bolero-a-restful-scaffold-with-scala" />


  <meta name="description" content="">
   <meta name="author" content="Scott">

  <title>
    
      
      Bolero——基于Scala、Play!和ReactiveMongo的RESTful代码模板 &middot; Code this.
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="https://scozv.github.io/blog/assets/themes/lanyon/css/poole.css">
  <link rel="stylesheet" href="https://scozv.github.io/blog/assets/themes/lanyon/css/syntax.css">
  <link rel="stylesheet" href="https://scozv.github.io/blog/assets/themes/lanyon/css/lanyon.css">
  <!-- <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400"> -->

  <!--[if lt IE 9]>
  <script src="https://scozv.github.io/blog/assets/themes/lanyon/resources/respond/Respond.min.js"></script>
  <![endif]-->

  <link href="https://scozv.github.io/blog/zh/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
  <link href="https://scozv.github.io/blog/zh/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

  <!-- Icons -->
  <link rel="shortcut icon" href="https://scozv.github.io/blog/assets/img/incognito_t.ico">

  <!-- Load KaTeX -->
  <link rel="stylesheet" href="https://scozv.github.io/blog/assets/katex/katex.min.css" />
  <link rel="stylesheet" href="https://scozv.github.io/blog/assets/katex/render.css" />
  <link rel="stylesheet" href="https://scozv.github.io/blog/assets/css/override.css">

  <script src="https://scozv.github.io/blog/assets/jquery/jquery.min.js"></script>
</head>


  <body class="layout-reverse sidebar-overlay">

    
      <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input
  type="checkbox"
  class="sidebar-checkbox"
  id="sidebar-checkbox"
  
>

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>Any Thoughts in Programming</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item"
      href="https://scozv.github.io/blog/zh">
      首页
    </a>
    

    
    
      
    
      
        
            <a class="sidebar-nav-item"
              href="https://scozv.github.io/blog/zh/archive/">
              
                归档
              
            </a>
        
      
    
      
        
      
    
      
        
            <a class="sidebar-nav-item"
              href="https://scozv.github.io/blog/zh/categories/">
              
                分类
              
            </a>
        
      
    
      
        
      
    
      
    
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
            <a class="sidebar-nav-item"
              href="https://scozv.github.io/blog/zh/tags/">
              
                标签
              
            </a>
        
      
    
      
    
      
    
      
    
      
        
            <a class="sidebar-nav-item"
              href="https://scozv.github.io/blog/zh/about/">
              
                关于
              
            </a>
        
      
    
      
        
      
    
  </nav>

  
  <div class="sidebar-item">
    <span class="force-mono-font">&copy;</span> 2019 &middot;
    <a href="https://github.com/scozv">Scott</a> &middot;
    <a href="https://scozv.github.io/blog/zh/credits">
      致谢
    </a> |
    <a style="font-weight: bold;"
      href="https://scozv.github.io/blog/guide/2016/07/27/bolero-a-restful-scaffold-with-scala">
        English
    </a>
  </div>
</div>


      <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
           content to avoid any CSS collisions with our real content. -->
      <div class="wrap">
        <div class="masthead">
          <div class="container">
            <h3 class="masthead-title">
              <a href="https://scozv.github.io/blog/zh"
                 title="首页">
                Code this.
              </a>
              <small>Any Thoughts in Programming</small>
            </h3>
          </div>
        </div>

        <div class="container content">
          



<div class="post">
  <h1 class="post-title">Bolero——基于Scala、Play!和ReactiveMongo的RESTful代码模板</h1>
  <span class="post-date">Jul 27, 2016</span>
  
<h1 class="no_toc" id="摘要">摘要</h1>

<blockquote>
  <p>本文介绍一套<code class="highlighter-rouge">RESTful</code>的代码模板（代号：<code class="highlighter-rouge">Bolero</code>）——使用<code class="highlighter-rouge">Scala</code>语言，基于<code class="highlighter-rouge">Play!</code>库以及<code class="highlighter-rouge">ReactiveMongo</code>。</p>

  <p>除了基本的HTTP Request和Response处理、MongoDB的异步读写之外，<code class="highlighter-rouge">Bolero</code>还包含如下功能：</p>

  <ul>
    <li><code class="highlighter-rouge">Model</code>的几个建议；</li>
    <li><code class="highlighter-rouge">RESTful API</code>设计的几个建议；</li>
    <li><code class="highlighter-rouge">CORS</code>跨域配置；</li>
    <li>基于Token认证的Request处理；</li>
    <li>全局范围内设计的一套Monad规则：<code class="highlighter-rouge">EitherOrError</code>；</li>
    <li>接收Webhook；</li>
    <li>基于<code class="highlighter-rouge">Specs2</code>的<code class="highlighter-rouge">FakeApplication</code>集成测试；</li>
    <li>基于<code class="highlighter-rouge">sbt-native</code>的发布脚本。</li>
  </ul>

  <p>本文（尤其是阅读源代码）需要有一定的<code class="highlighter-rouge">Scala</code>语言基础，需要对Monad有初步的理解。
最好能够（熟练地）使用<code class="highlighter-rouge">Future[T]</code>。</p>

  <p><code class="highlighter-rouge">Bolero</code>目前主要基于<code class="highlighter-rouge">Play!</code>框架（<code class="highlighter-rouge">2.4</code>），但是不包含任何View的部分，所有的Action都返回<code class="highlighter-rouge">JSON</code>对象。
我计划用<code class="highlighter-rouge">Spary.io</code>代替<code class="highlighter-rouge">Play!</code>。</p>

  <p><code class="highlighter-rouge">Bolero</code>的源代码参见 <a href="https://github.com/scozv/bolero">scozv/bolero</a>。</p>
</blockquote>

<!--more-->

<ul id="markdown-toc">
  <li><a href="#bolero设计的基本理念" id="markdown-toc-bolero设计的基本理念"><code class="highlighter-rouge">Bolero</code>设计的基本理念</a>    <ul>
      <li><a href="#松耦合的架构思想" id="markdown-toc-松耦合的架构思想">松耦合的架构思想</a></li>
      <li><a href="#建模中的一些问题命名多态和序列化" id="markdown-toc-建模中的一些问题命名多态和序列化">建模中的一些问题：命名、多态和序列化</a></li>
      <li><a href="#restful-api设计的几个建议" id="markdown-toc-restful-api设计的几个建议"><code class="highlighter-rouge">RESTful API</code>设计的几个建议</a>        <ul>
          <li><a href="#restful-api的几个要素" id="markdown-toc-restful-api的几个要素"><code class="highlighter-rouge">RESTful API</code>的几个要素</a></li>
          <li><a href="#一致的payload和response设计" id="markdown-toc-一致的payload和response设计">一致的Payload和Response设计</a></li>
          <li><a href="#限制跨域还是开放跨域" id="markdown-toc-限制跨域还是开放跨域">限制跨域还是开放跨域</a></li>
          <li><a href="#名词单复数以及排序" id="markdown-toc-名词单复数以及排序">名词、单复数以及排序</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#开发代码详解" id="markdown-toc-开发代码详解">开发代码详解</a>    <ul>
      <li><a href="#models中的几个trait解释" id="markdown-toc-models中的几个trait解释"><code class="highlighter-rouge">models</code>中的几个<code class="highlighter-rouge">trait</code>解释</a>        <ul>
          <li><a href="#canbehierarchic层级类" id="markdown-toc-canbehierarchic层级类"><code class="highlighter-rouge">CanBeHierarchic</code>，层级类</a></li>
          <li><a href="#canbejsonfiedreads和writes的通用处理" id="markdown-toc-canbejsonfiedreads和writes的通用处理"><code class="highlighter-rouge">CanBeJsonfied</code>，<code class="highlighter-rouge">Reads</code>和<code class="highlighter-rouge">Writes</code>的通用处理</a></li>
          <li><a href="#canbemasked敏感字段的掩盖" id="markdown-toc-canbemasked敏感字段的掩盖"><code class="highlighter-rouge">CanBeMasked</code>，敏感字段的掩盖</a></li>
        </ul>
      </li>
      <li><a href="#orderorerror基于monad设计的全局规则校验" id="markdown-toc-orderorerror基于monad设计的全局规则校验"><code class="highlighter-rouge">OrderOrError</code>——基于Monad设计的全局规则校验</a></li>
      <li><a href="#cancrossorigin处理option以应对跨域" id="markdown-toc-cancrossorigin处理option以应对跨域"><code class="highlighter-rouge">CanCrossOrigin</code>——处理<code class="highlighter-rouge">OPTION</code>以应对跨域</a></li>
      <li><a href="#canconnectdb2t统一处理数据的读写" id="markdown-toc-canconnectdb2t统一处理数据的读写"><code class="highlighter-rouge">CanConnectDB2[T]</code>——统一处理数据的读写</a></li>
      <li><a href="#基于token的用户认证" id="markdown-toc-基于token的用户认证">基于Token的用户认证</a></li>
    </ul>
  </li>
  <li><a href="#测试代码详解" id="markdown-toc-测试代码详解">测试代码详解</a>    <ul>
      <li><a href="#测试文件的结构" id="markdown-toc-测试文件的结构">测试文件的结构</a></li>
      <li><a href="#测试的无状态" id="markdown-toc-测试的无状态">测试的无状态</a></li>
      <li><a href="#canfakehttp不依赖任何客户端的restful测试" id="markdown-toc-canfakehttp不依赖任何客户端的restful测试"><code class="highlighter-rouge">CanFakeHTTP</code>——不依赖任何客户端的<code class="highlighter-rouge">RESTful</code>测试</a></li>
    </ul>
  </li>
  <li><a href="#发布和部署介绍" id="markdown-toc-发布和部署介绍">发布和部署介绍</a></li>
  <li><a href="#参考文献" id="markdown-toc-参考文献">参考文献</a></li>
</ul>

<h1 id="bolero设计的基本理念"><code class="highlighter-rouge">Bolero</code>设计的基本理念</h1>

<p>本文介绍的这一套<code class="highlighter-rouge">RESTful</code>的代码模板，代号为<code class="highlighter-rouge">Bolero</code>，以下就将该套模板
称为<code class="highlighter-rouge">Bolero</code>。<code class="highlighter-rouge">Bolero</code>的源代码参见：</p>

<p><a href="https://github.com/scozv/bolero">https://github.com/scozv/bolero</a></p>

<p>先来看<code class="highlighter-rouge">Bolero</code>设计的一些基本理念。</p>

<h2 id="松耦合的架构思想">松耦合的架构思想</h2>

<p><code class="highlighter-rouge">Bolero</code>基于松耦合 <sup id="fnref:scozv_blog_archi"><a href="#fn:scozv_blog_archi" class="footnote">1</a></sup> 的思想，就前后端分离而言：</p>

<ul>
  <li><code class="highlighter-rouge">Bolero</code>只负责后端，我没有使用<code class="highlighter-rouge">Play!</code>提供的<code class="highlighter-rouge">View</code>引擎，并且计划使用<code class="highlighter-rouge">Spary.io</code>代替<code class="highlighter-rouge">Play!</code>；</li>
  <li>作为后台服务，<code class="highlighter-rouge">Bolero</code>保证所有的HTTP Response都是<code class="highlighter-rouge">JSON</code>格式，都使用<code class="highlighter-rouge">RESTful</code>的方式呈现。</li>
</ul>

<p>可以使用<code class="highlighter-rouge">Bolero</code>创建多个服务，不过目前，<code class="highlighter-rouge">Bolero</code>并不是一个Microservices的框架。
关于微服务，可以关注Lightbend推出的<code class="highlighter-rouge">Lagom</code>框架，<code class="highlighter-rouge">Lagom</code>的<code class="highlighter-rouge">Scala</code>版本正在进行中 <sup id="fnref:lagom_issue1"><a href="#fn:lagom_issue1" class="footnote">2</a></sup>。</p>

<h2 id="建模中的一些问题命名多态和序列化">建模中的一些问题：命名、多态和序列化</h2>

<p>数据的传递方向，一个是从前端通过HTTP Request将<code class="highlighter-rouge">payload</code>数据传递给后端，
后端转换（<code class="highlighter-rouge">Validate[T]</code>）为代码层面的<code class="highlighter-rouge">models</code>，
经过数据处理之后，持久化到数据库<code class="highlighter-rouge">MongoDB</code>中。</p>

<p>另一个方向反之，从数据库读、代码层面加工，最后通过HTTP Response返回给前端。</p>

<p>因此，整个过程中有三个层面需要建模：</p>

<ul>
  <li>前端建模，虽然<code class="highlighter-rouge">JavaScript</code>是弱类型，但是建议使用<code class="highlighter-rouge">TypeScript</code>在前端建模；</li>
  <li>代码层面，在<code class="highlighter-rouge">Bolero</code>中，对应地使用<code class="highlighter-rouge">Scala</code>设计接口（<code class="highlighter-rouge">trait</code>）和类（<code class="highlighter-rouge">class</code>）；</li>
  <li>数据库层面，对应的就是<code class="highlighter-rouge">MongoDB</code>的设计。</li>
</ul>

<p>在这三个层面中，<code class="highlighter-rouge">Bolero</code>使用或者建议的命名规范是：</p>

<ul>
  <li>所有的主键都叫<code class="highlighter-rouge">_id</code>；</li>
  <li>对象名使用驼峰命名，首字母大写；</li>
  <li>对象中的字段使用驼峰命名，首字母小写。</li>
</ul>

<p>这样，保证了三个层面上的数据建模都是一模一样的。</p>

<p>此处有备住：</p>

<blockquote>
  <p>以上的数据建模规范，不一定是最佳的实践。另外，我正在考虑将前端和数据库层面的建模，
修改为下划线风格，代码层面继续使用驼峰。我是指，“我在考虑，但并没有决定”。</p>
</blockquote>

<p><code class="highlighter-rouge">Play!</code>中提供了<code class="highlighter-rouge">Reads</code>和<code class="highlighter-rouge">Writes</code>模块 <sup id="fnref:play_json"><a href="#fn:play_json" class="footnote">3</a></sup>，用来处理对象类和<code class="highlighter-rouge">JSON</code>之间
的转换：类到<code class="highlighter-rouge">JSON</code>我们用<code class="highlighter-rouge">Writes</code>，表示“写”；<code class="highlighter-rouge">JSON</code>到类，我们用<code class="highlighter-rouge">Reads</code>，表明“读”。</p>

<p><code class="highlighter-rouge">Play!</code>中也提供了用于automated mapping的<code class="highlighter-rouge">JSON</code>读写 <sup id="fnref:play_json_auto"><a href="#fn:play_json_auto" class="footnote">4</a></sup>：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">play.api.libs.json._</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">autoReads</span> <span class="k">=</span> <span class="nc">Json</span><span class="o">.</span><span class="n">reads</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">autoWrites</span> <span class="k">=</span> <span class="nc">Json</span><span class="o">.</span><span class="n">writes</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>

<span class="c1">// format = reads + writes
</span><span class="k">implicit</span> <span class="k">val</span> <span class="n">autoFormat</span> <span class="k">=</span> <span class="nc">Json</span><span class="o">.</span><span class="n">format</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span></code></pre></figure>

<p>此处有建议：</p>

<blockquote>
  <p>尽管<code class="highlighter-rouge">Play!</code>提供了automated mapping，但是对于<code class="highlighter-rouge">models</code>比较复杂的
系统，我建议手动配置<code class="highlighter-rouge">Reads</code>和<code class="highlighter-rouge">Writes</code>（<strong>前提是，要有完备的读写测试来覆盖代码</strong>）：</p>

  <ul>
    <li>
      <p>当任何一层的建模，发生更改的时候，我们必须手动去对应地修改<code class="highlighter-rouge">Reads</code>和<code class="highlighter-rouge">Writes</code>，
否则将会收到如下异常，此举，可以保证我们代码的质量：</p>

      <div class="highlighter-rouge"><pre class="highlight"><code> play.api.libs.json.JsResultException: "obj.field_name":{"msg":["error.path.missing"]
</code></pre>
      </div>
    </li>
    <li>
      <p>手动配置<code class="highlighter-rouge">Reads</code>和<code class="highlighter-rouge">Writes</code>的另一个原因就是，可以更加自由地处理<code class="highlighter-rouge">JSON</code>的序列化：</p>
      <ul>
        <li><code class="highlighter-rouge">Option[T]</code>为<code class="highlighter-rouge">None</code>时，可以不用<code class="highlighter-rouge">Writes</code>；</li>
        <li>可以兼容<code class="highlighter-rouge">Scala</code>建模用驼峰、<code class="highlighter-rouge">MongoDB</code>建模用下划线的情况。</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>目前系统的建模，通常离不开继承和多态，使用<code class="highlighter-rouge">Reads</code>和<code class="highlighter-rouge">Writes</code>时，可能会遇到如下异常：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">ambiguous</span> <span class="n">reference</span> <span class="n">to</span> <span class="n">overloaded</span> <span class="n">definition</span></code></pre></figure>

<p>表明某一个类的<code class="highlighter-rouge">Reads</code>或者<code class="highlighter-rouge">Writes</code>有重复定义的情况。我之前花了9个<code class="highlighter-rouge">git commits</code>来处理这个问题。
你可以参考<code class="highlighter-rouge">Bolero</code>的<a href="https://github.com/scozv/bolero">源代码</a>，或者给我看看错误信息。</p>

<h2 id="restful-api设计的几个建议"><code class="highlighter-rouge">RESTful API</code>设计的几个建议</h2>

<p>再次强调，<code class="highlighter-rouge">Bolero</code>只提供<code class="highlighter-rouge">RESTful</code>的服务，不提供View渲染。所有的
<code class="highlighter-rouge">RESTful API</code>返回的都是<code class="highlighter-rouge">JSON</code>对象。</p>

<h3 id="restful-api的几个要素"><code class="highlighter-rouge">RESTful API</code>的几个要素</h3>

<p>通常而言，<code class="highlighter-rouge">RESTful</code>接口在设计的时候，需要考虑这些要素：</p>

<ul>
  <li>HTTP Method：<code class="highlighter-rouge">GET</code>、<code class="highlighter-rouge">POST</code>、<code class="highlighter-rouge">PUT</code>等 <sup id="fnref:rest_http_method"><a href="#fn:rest_http_method" class="footnote">5</a></sup>；</li>
  <li>资源路径，比如<code class="highlighter-rouge">/user/:id/profile</code>，可以在路径加入适当的参数，用来排序、分页或者筛选；</li>
  <li><code class="highlighter-rouge">payload</code>数据，传递给<code class="highlighter-rouge">RSETful</code>服务的<code class="highlighter-rouge">JSON</code>数据；</li>
  <li>HTTP Header：可以为当前的HTTP Request添加一些元数据，比如Token认证过程中的用户身份Token；</li>
  <li>HTTP Response：服务传递回来的<code class="highlighter-rouge">JSON</code>结果。</li>
</ul>

<h3 id="一致的payload和response设计">一致的Payload和Response设计</h3>

<p>如果你经常使用<code class="highlighter-rouge">Scala</code>中的<code class="highlighter-rouge">map()</code>，你就会发现如下的一致性原则：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">T</span><span class="o">.</span><span class="n">map</span><span class="o">()</span><span class="k">:</span> <span class="kt">T</span>
<span class="c1">// such as
</span><span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">].</span><span class="n">map</span><span class="o">()</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="nc">Future</span><span class="o">[</span><span class="kt">A</span><span class="o">].</span><span class="n">map</span><span class="o">()</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span></code></pre></figure>

<p>受这一原则的启发，我在<code class="highlighter-rouge">Bolero</code>的<code class="highlighter-rouge">RESTful API</code>设计中，很多时候
<code class="highlighter-rouge">payload</code>和HTTP Response的数据结构都是一样的，比如，
如下是购物车页面，提交，生成（返回）带<code class="highlighter-rouge">_id</code>的订单的<code class="highlighter-rouge">RESTful</code>接口：</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html">POST /checkout

// Request
// header: Token for authentication
payload: "Bolero.models.Order"

// Response
data: "Bolero.models.Order"</code></pre></figure>

<p>这样的设计，让接口的使用变得更简单——只需要记住一个数据结构。</p>

<h3 id="限制跨域还是开放跨域">限制跨域还是开放跨域</h3>

<p>CORS是Cross Origin Resource Sharing <sup id="fnref:mdn_cors"><a href="#fn:mdn_cors" class="footnote">6</a></sup> 的简写。</p>

<p>最初在设计<code class="highlighter-rouge">Bolero</code>的时候，我是限制跨域的，我只希望某一个指定的<code class="highlighter-rouge">IP</code>客户端，才能访问<code class="highlighter-rouge">Bolero</code>接口。
但是，当我后来需要接入Ping++支付的Webhook的时候，限制跨域就不能同时满足客户端和Ping++的访问了。</p>

<p>因为，<code class="highlighter-rouge">Access-Control-Allow-Origin</code>
并不支持多域（multiple origin）同时跨域访问 <sup id="fnref:w3_cors_multi_issue"><a href="#fn:w3_cors_multi_issue" class="footnote">7</a></sup>：</p>

<blockquote>
  <p>In practice the <code class="highlighter-rouge">origin-list-or-null</code> production is more constrained.
Rather than allowing a space-separated list of origins,
<strong>it is either a single origin or the string “null”</strong>.</p>
</blockquote>

<p>另外，面对松耦合和多个客户端的实例部署，限制跨域不是一个通用的选择。</p>

<p>如果真的想控制跨域，或者统计HTTP Request的来源，可以选择：</p>

<ul>
  <li>在<code class="highlighter-rouge">Bolero</code>中，使用<code class="highlighter-rouge">Play!</code>的<code class="highlighter-rouge">Filters</code><sup id="fnref:play_filter"><a href="#fn:play_filter" class="footnote">8</a></sup>，
从HTTP Request中的<code class="highlighter-rouge">origin</code>信息<sup id="fnref:play_rqst_header"><a href="#fn:play_rqst_header" class="footnote">9</a></sup> 来控制访问源（目前<code class="highlighter-rouge">Bolero</code>并没有这么做）；</li>
  <li>在客户端的Ｗeb Server层面，控制访问源，也就是，对于一些异常的高频访问，Web Server
都不会将该HTTP Request发送给<code class="highlighter-rouge">Bolero</code>服务。</li>
</ul>

<h3 id="名词单复数以及排序">名词、单复数以及排序</h3>

<p><code class="highlighter-rouge">Bolero</code>在设计<code class="highlighter-rouge">RESTful API</code>的时候，还有如下几个原则：</p>

<ul>
  <li>资源地址（<code class="highlighter-rouge">URL</code>）中只使用名词，最好使用简单名词，
不应该出现除反斜线（<code class="highlighter-rouge">/</code>）以外的其它字符，也不能采用驼峰的命名风格；</li>
  <li>
    <p>资源地址（<code class="highlighter-rouge">URL</code>）中的名词，统一使用单数，就算是返回一个数组，也应该使用单数，比如：</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>// get the list of user
GET /user
// get a user with specific id
GET /user/:id
</code></pre>
    </div>

    <p>我们将单个的用户看作一个文件（<code class="highlighter-rouge">:id</code>），将这些文件都放进一个叫<code class="highlighter-rouge">user</code>的目录。我们拿单个的文件，或者
取整个文件夹，都会经过<code class="highlighter-rouge">/user</code>这个路径，不会一个用<code class="highlighter-rouge">/user</code>；整体用<code class="highlighter-rouge">/users</code>。
所以我们的<code class="highlighter-rouge">URL</code>中的名词也按照这个原则设计；</p>
  </li>
  <li>如果HTTP Response的是一个数组，那么我们是否需要将该数组排序？<code class="highlighter-rouge">Bolero</code>的HTTP Response排序原则是：
    <ul>
      <li>如果HTTP Request指定了排序规则，则按照该规则排序；</li>
      <li>如果该接口对应的业务有默认的排序规则，则按照该规则排序；</li>
      <li>其它情况，<code class="highlighter-rouge">Bolero</code>并不保证HTTP Response的有序性。</li>
    </ul>
  </li>
</ul>

<h1 id="开发代码详解">开发代码详解</h1>

<p><code class="highlighter-rouge">Bolero</code>的源代码见：<a href="https://github.com/scozv/bolero">scozv/bolero</a>　。</p>

<p>该源代码的文件结构为：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">.
├── app
|   ├── base                // API中的辅助类
|   ├── biz                 // 业务处理，仅仅在这一层做数据库的读写
|   ├── contollers          // MVC 中的控制器
|   └── models              
|       ├── interop         // 第三方接口的models
|       └── model.scala     // Scala建模
|
├── conf                    // Play!的配置文件
|   ├── application.conf
|   ├── play.plugins
|   ├── release.conf
|   └── routes
|
├── project                  // 项目编译配置
|   ├── build.properties
|   └── plugin.sbt
|
├── <span class="nb">test</span>                     // 测试脚本
|
└── build.sbt</code></pre></figure>

<h2 id="models中的几个trait解释"><code class="highlighter-rouge">models</code>中的几个<code class="highlighter-rouge">trait</code>解释</h2>

<h3 id="canbehierarchic层级类"><code class="highlighter-rouge">CanBeHierarchic</code>，层级类</h3>

<p>层级类表示一系列有关联的类。使用并查集的算法，也就是：</p>

<ul>
  <li>根节点的<code class="highlighter-rouge">rootId</code>为其本身；</li>
  <li>任意两个实例，如果两者的<code class="highlighter-rouge">rootId</code>相等，则表示这两者是相互关联的。</li>
</ul>

<h3 id="canbejsonfiedreads和writes的通用处理"><code class="highlighter-rouge">CanBeJsonfied</code>，<code class="highlighter-rouge">Reads</code>和<code class="highlighter-rouge">Writes</code>的通用处理</h3>

<p>参考<code class="highlighter-rouge">models.Goods</code>中使用<code class="highlighter-rouge">CanBeJsonfied</code>的方式 <sup id="fnref:scozv_git_goods"><a href="#fn:scozv_git_goods" class="footnote">10</a></sup>。</p>

<h3 id="canbemasked敏感字段的掩盖"><code class="highlighter-rouge">CanBeMasked</code>，敏感字段的掩盖</h3>

<p><code class="highlighter-rouge">Bolero</code>在将数据Response给前端的时候，有些敏感字段，是不应该返回出去的，比如用户<code class="highlighter-rouge">_id</code>，
或者商品的成本价格。使用<code class="highlighter-rouge">CanBeMasked</code>接口，在Action那边，统一调用<code class="highlighter-rouge">T.asMasked()</code>，将敏感信息抹除。</p>

<p>Mask这个命名，受Oracle Data Masking <sup id="fnref:oracle_mask"><a href="#fn:oracle_mask" class="footnote">11</a></sup> 的启发。</p>

<h2 id="orderorerror基于monad设计的全局规则校验"><code class="highlighter-rouge">OrderOrError</code>——基于Monad设计的全局规则校验</h2>

<p>就拿创建订单来看，通常订单的创建，会有一系列的规则需要校验：</p>

<ul>
  <li>该用户是否有权限创建订单；</li>
  <li>订单中的商品数量是否满足库存；</li>
  <li>订单中的商品价格是否不小于当前价格；</li>
  <li>是否满足订单中列明的优惠；</li>
  <li>等等等等。</li>
</ul>

<p><code class="highlighter-rouge">OrderOrError</code>的思路就是，对于任何一条规则，我们保证校验的结果：</p>

<ul>
  <li>要么是原来的订单<code class="highlighter-rouge">order</code>，当此订单通过了校验；</li>
  <li>要么是<code class="highlighter-rouge">error</code>信息</li>
</ul>

<p>此处，借用了<code class="highlighter-rouge">Scala</code>对<code class="highlighter-rouge">Try</code> <sup id="fnref:scala_try"><a href="#fn:scala_try" class="footnote">12</a></sup> 的设计：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">type</span> <span class="kt">OrderOrError</span> <span class="o">=</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">Order</span>, <span class="kt">Error</span><span class="o">]</span>

<span class="k">def</span> <span class="n">genericValidation</span><span class="o">(</span><span class="n">order</span><span class="k">:</span> <span class="kt">Order</span><span class="o">,</span> <span class="n">db</span><span class="k">:</span> <span class="kt">DB</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">OrderOrError</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="o">???</span>
  <span class="cm">/*
  * we connect DB and validate the order,
  * so a Future[T] will be returned
  * */</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">genericRule</span>
<span class="o">(</span><span class="n">order</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">OrderOrError</span><span class="o">],</span> <span class="n">db</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">DB</span><span class="o">)</span>
<span class="o">(</span><span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">OrderOrError</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">order</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Future</span><span class="o">.</span><span class="n">successful</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">e</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">o</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">genericValidation</span><span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="n">db</span><span class="o">)</span>
  <span class="o">}</span></code></pre></figure>

<p>此处有备注：</p>

<blockquote>
  <p>严格意义上讲，上述的设计并不是Monad模式，因为，它没有实现两个关键的方法 <sup id="fnref:scozv_bolero_issue1"><a href="#fn:scozv_bolero_issue1" class="footnote">13</a></sup>：</p>

  <div class="highlighter-rouge"><pre class="highlight"><code>  ModelOrError[A].map(A =&gt; B): ModelOrError[B]
  ModelOrError[A].flatMap(A =&gt; ModelOrError[B]): ModelOrError[B]
</code></pre>
  </div>

  <p>我正在考虑和设计。</p>
</blockquote>

<h2 id="cancrossorigin处理option以应对跨域"><code class="highlighter-rouge">CanCrossOrigin</code>——处理<code class="highlighter-rouge">OPTION</code>以应对跨域</h2>

<p>跨域的处理有两个地方，需要实现：</p>

<ul>
  <li>定义<code class="highlighter-rouge">OPTION</code>路由；</li>
  <li>处理<code class="highlighter-rouge">OPTION</code>，返回<code class="highlighter-rouge">HTTP 200</code>。</li>
</ul>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// routes
// OPTIONS       /*path        controllers.CORSController.preFlight(path)
// controllers
</span><span class="k">class</span> <span class="nc">CORSController</span>
  <span class="k">extends</span> <span class="nc">Controller</span>
  <span class="k">with</span> <span class="nc">CanCrossOrigin</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">preFlight</span><span class="o">(</span><span class="n">path</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Action</span> <span class="o">{</span> <span class="n">request</span> <span class="k">=&gt;</span>
    <span class="n">corsOPTION</span><span class="o">(</span><span class="n">path</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// CanCrossOrigin
</span><span class="k">trait</span> <span class="nc">CanCrossOrigin</span> <span class="o">{</span>
  <span class="n">self</span><span class="k">:</span> <span class="kt">Controller</span> <span class="o">=&gt;</span>

  <span class="k">def</span> <span class="n">corsOPTION</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"..."</span><span class="o">)</span><span class="k">:</span> <span class="kt">Result</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">???</span>
    <span class="c1">// add Access-Control-Allow-Origin to header
</span>  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h2 id="canconnectdb2t统一处理数据的读写"><code class="highlighter-rouge">CanConnectDB2[T]</code>——统一处理数据的读写</h2>

<p><code class="highlighter-rouge">CanConnectDB2[T]</code>是对原先的<code class="highlighter-rouge">CanConnectDB</code>的改写。
主要的意图是，让开发人员尽可能地少写重复的代码。</p>

<p>具体的代码变更，参考<code class="highlighter-rouge">biz.Can.scala</code>，也可以访问<a href="https://github.com/scozv/bolero/commit/b0a5fd3c3ab58159305711e6e0f742786fccc30b">代码变更记录</a>。</p>

<p>目前提供如下的接口实现：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">CanConnectDB2</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// 查询所有的T
</span>  <span class="k">def</span> <span class="n">list</span><span class="o">(</span><span class="n">db</span><span class="k">:</span> <span class="kt">DB</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="o">???</span>
  <span class="c1">// 查询一个指定_id的T
</span>  <span class="k">def</span> <span class="n">one</span><span class="o">(</span><span class="n">db</span><span class="k">:</span> <span class="kt">DB</span><span class="o">,</span> <span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="o">???</span>
  <span class="c1">// 查询指定_id的T的一个字段
</span>  <span class="k">def</span> <span class="n">field</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">db</span><span class="k">:</span> <span class="kt">DB</span><span class="o">,</span> <span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">fieldName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span> <span class="k">=</span> <span class="o">???</span>
  <span class="c1">// 查询一系列T的指定字段的所有值
</span>  <span class="k">def</span> <span class="n">sequence</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">db</span><span class="k">:</span> <span class="kt">DB</span><span class="o">,</span> <span class="n">selector</span><span class="k">:</span> <span class="kt">JsObject</span><span class="o">,</span> <span class="n">fieldName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span> <span class="k">=</span> <span class="o">???</span>
  <span class="c1">// 插入一条T
</span>  <span class="k">def</span> <span class="n">insert</span><span class="o">(</span><span class="n">db</span><span class="k">:</span> <span class="kt">DB</span><span class="o">,</span> <span class="n">document</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">WriteResult</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
  <span class="c1">// 更新符合selector条件的一系列T
</span>  <span class="k">def</span> <span class="n">update</span><span class="o">(</span><span class="n">db</span><span class="k">:</span> <span class="kt">DB</span><span class="o">,</span> <span class="n">selector</span><span class="k">:</span> <span class="kt">JsObject</span><span class="o">,</span> <span class="n">update</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">UpdateWriteResult</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
  <span class="c1">// 更新指定_id的T
</span>  <span class="k">def</span> <span class="n">edit</span><span class="o">(</span><span class="n">db</span><span class="k">:</span> <span class="kt">DB</span><span class="o">,</span> <span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">update</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span><span class="kt">Future</span><span class="o">[</span><span class="kt">UpdateWriteResult</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span></code></pre></figure>

<h2 id="基于token的用户认证">基于Token的用户认证</h2>

<p><code class="highlighter-rouge">Bolero</code>的所有接口都是无状态的，识别用户的方式，就是通过Authentication Token。
在Google中搜索该名词，可以了解更多，也可以找到<code class="highlighter-rouge">auth0</code>的帖子 <sup id="fnref:auth0_token"><a href="#fn:auth0_token" class="footnote">14</a></sup>。</p>

<p>我正在写一篇关于Token认证的帖子<sup id="fnref:scozv_blog_auth_token"><a href="#fn:scozv_blog_auth_token" class="footnote">15</a></sup>，
目前还没有完成，你可以在参考文献中找到该帖子的草稿。</p>

<p>此处有提醒：</p>

<blockquote>
  <p>我对安全认证这一领域，还是很多不了解的地方。<code class="highlighter-rouge">Bolero</code>对Token认证的实现不能保证100%
安全，我还在不断地改进中。</p>
</blockquote>

<p>在<code class="highlighter-rouge">Bolero</code>里面，使用了<code class="highlighter-rouge">Play!</code>提供的
Action composition <sup id="fnref:play_composition"><a href="#fn:play_composition" class="footnote">16</a></sup> 来完成Token认证。</p>

<p>具体的实现，参考<code class="highlighter-rouge">controllers.CanAuthenticate.scala</code>。</p>

<h1 id="测试代码详解">测试代码详解</h1>

<blockquote>
  <p><strong>测试非常重要 <sup id="fnref:scozv_blog_jira"><a href="#fn:scozv_blog_jira" class="footnote">17</a></sup>，完备的测试是重构和持续集成的基础。</strong></p>

  <p><strong>测试非常重要，完备的测试是重构和持续集成的基础。</strong></p>

  <p><strong>测试非常重要，完备的测试是重构和持续集成的基础。</strong></p>
</blockquote>

<p>测试的<a href="https://github.com/scozv/bolero">源代码</a>见<code class="highlighter-rouge">test</code>目录。</p>

<h2 id="测试文件的结构">测试文件的结构</h2>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">.
├── <span class="nb">test</span>
|   ├── WithApplication.scala         // 升级至Play 2.4之后，使用旧版的WithApplication
|   ├── CanConnectDB.scala            // 连接到测试数据库
|   ├── CanFakeHTTP.scala             // 伪造HTTP Request
|   └── BoleroApplicationSpec.scala   // 具体的测试脚本，可以将不同的测试逻辑分割成不同的文件</code></pre></figure>

<h2 id="测试的无状态">测试的无状态</h2>

<p>测试的脚本，要保证在任何库上都能通过，当然，这和测试用例的设计有关。</p>

<p>通常，我们在测试开始时，准备数据，在测试完成之后，清理测试数据。</p>

<h2 id="canfakehttp不依赖任何客户端的restful测试"><code class="highlighter-rouge">CanFakeHTTP</code>——不依赖任何客户端的<code class="highlighter-rouge">RESTful</code>测试</h2>

<p>基于松耦合的原则，<code class="highlighter-rouge">RESTful</code>服务的开发流程中，不应该依赖前端View的开发进程。
所以，我们使用<code class="highlighter-rouge">CanFakeHTTP</code>模拟HTTP Request。</p>

<h1 id="发布和部署介绍">发布和部署介绍</h1>

<p>使用<code class="highlighter-rouge">Bolero</code>的一个生产环境目前部署在<code class="highlighter-rouge">Ubuntu 14.04</code>上面。</p>

<p>部署脚本，可以参考<code class="highlighter-rouge">deploy.sh</code>，最好在<code class="highlighter-rouge">Ubuntu 14.04</code>上运行。该脚本
使用了<code class="highlighter-rouge">sbt-native-packager</code> <sup id="fnref:scala_sbt_native"><a href="#fn:scala_sbt_native" class="footnote">18</a></sup> 作常驻发布。</p>

<p>另外，在实际的使用中<code class="highlighter-rouge">Bolero</code>的生产配置对开发是不可见的。
我通常会使用多个<code class="highlighter-rouge">git repo</code>来托管源代码（假定项目代号为<code class="highlighter-rouge">PJ</code>）：</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">pj-docs                 <span class="c"># 文档中心，使用`Markdown`来写项目的所有文档</span>
pj-core-restful         <span class="c"># 本文的主要内容，使用`Bolero`代码模板</span>
pj-core-web             <span class="c"># 核心的Web建模，使用`TypeScript`建模</span>
pj-client-web           <span class="c"># View层，通用的用户访问页面，使用`pj-core-web`</span>
pj-client-device        <span class="c"># View层，App客户端</span>
pj-client-console       <span class="c"># View层，系统的后台管理平台，使用`pj-core-web`</span>
pj-deploy               <span class="c"># 以上所有`repo`的发布配置脚本，对开发不可见</span>
pj-data                 <span class="c"># 生产环境的数据备份，对开发不可见</span></code></pre></figure>

<h1 id="参考文献">参考文献</h1>

<div class="footnotes">
  <ol>
    <li id="fn:scozv_blog_archi">
      <p><a href="https://scozv.github.io/blog/zh/pattern/2016/05/05/a-low-coupling-architecture-of-the-web-solution-with-continuous-integration">基于低耦合和持续集成的Web架构</a>&nbsp;<a href="#fnref:scozv_blog_archi" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:lagom_issue1">
      <p><a href="https://github.com/lagom/lagom/issues/1"><code class="highlighter-rouge">Lagom</code> issue #1 Add Scala API</a>&nbsp;<a href="#fnref:lagom_issue1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:play_json">
      <p><a href="https://www.playframework.com/documentation/2.5.x/ScalaJsonCombinators"><code class="highlighter-rouge">Play!</code> JSON Reads/Writes/Format Combinators</a>&nbsp;<a href="#fnref:play_json" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:play_json_auto">
      <p><a href="https://www.playframework.com/documentation/2.5.x/ScalaJsonAutomated"><code class="highlighter-rouge">Play!</code> JSON automated mapping</a>&nbsp;<a href="#fnref:play_json_auto" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:rest_http_method">
      <p><a href="http://www.restapitutorial.com/lessons/httpmethods.html">Using HTTP Methods for RESTful Services</a>&nbsp;<a href="#fnref:rest_http_method" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:mdn_cors">
      <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">HTTP access control (CORS)</a>&nbsp;<a href="#fnref:mdn_cors" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:w3_cors_multi_issue">
      <p><a href="https://www.w3.org/TR/cors/#access-control-allow-origin-response-header">5.1 Access-Control-Allow-Origin Response Header</a> from w3.org&nbsp;<a href="#fnref:w3_cors_multi_issue" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:play_filter">
      <p><a href="https://www.playframework.com/documentation/2.5.x/ScalaHttpFilters"><code class="highlighter-rouge">Play!</code> Filters</a>&nbsp;<a href="#fnref:play_filter" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:play_rqst_header">
      <p><a href="https://www.playframework.com/documentation/2.5.x/api/scala/index.html#play.api.mvc.RequestHeader"><code class="highlighter-rouge">play.api.mvc.RequestHeader</code></a>&nbsp;<a href="#fnref:play_rqst_header" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:scozv_git_goods">
      <p><a href="https://github.com/scozv/bolero/blob/master/app/models/Goods.scala#L28"><code class="highlighter-rouge">models.Goods</code></a>&nbsp;<a href="#fnref:scozv_git_goods" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:oracle_mask">
      <p><a href="http://www.oracle.com/technetwork/database/options/data-masking-subsetting/overview/index.html">Oracle Data Masking and Subsetting Pack</a>&nbsp;<a href="#fnref:oracle_mask" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:scala_try">
      <p><a href="http://www.scala-lang.org/api/2.9.3/scala/util/Try.html"><code class="highlighter-rouge">scala.util.Try</code></a>&nbsp;<a href="#fnref:scala_try" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:scozv_bolero_issue1">
      <p><a href="https://github.com/scozv/bolero/issues/1"><code class="highlighter-rouge">Bolero</code> issue #1 monad ModelOrError needed</a>&nbsp;<a href="#fnref:scozv_bolero_issue1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:auth0_token">
      <p><a href="https://auth0.com/blog/2014/01/07/angularjs-authentication-with-cookies-vs-token/">Cookies vs Tokens. Getting auth right with Angular.JS</a>&nbsp;<a href="#fnref:auth0_token" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:scozv_blog_auth_token">
      <p><a href="https://github.com/scozv/blog/blob/master/_drafts/2016-05-12-understanding-of-login-and-the-token-based-authentication.md">对登录和基于Token的认证机制的理解（草稿）</a>&nbsp;<a href="#fnref:scozv_blog_auth_token" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:play_composition">
      <p><a href="https://www.playframework.com/documentation/2.5.x/ScalaActionsComposition"><code class="highlighter-rouge">Play!</code> Action composition</a>&nbsp;<a href="#fnref:play_composition" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:scozv_blog_jira">
      <p><a href="https://scozv.github.io/blog/zh/guide/2016/04/05/fully-migrating-from-bitbucket-cloud-issue-system-to-jira-server">Bitbucket Cloud的Issue至JIRA Server的完全迁移指南</a>&nbsp;<a href="#fnref:scozv_blog_jira" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:scala_sbt_native">
      <p><a href="[^scala_sbt_native]">Debian Plugin</a>&nbsp;<a href="#fnref:scala_sbt_native" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

</div>

<div class="related">
  

    
    
        
            
                
                <h4>您也许还想读……</h4>
                <ul class="related-posts">
                
                <li>
                    <a href="https://scozv.github.io/blog/zh/pattern/2017/07/18/injection-of-tracking-id-to-logback-message-with-customer-dispatcher-and-mapped-diagnostic-contexts-in-scala">
                      使用自定义Akka Dispatcher和Mapped Diagnostic Contexts为Play中的日志增加Tracking Id
                      <small>Jul 18, 2017</small>
                    </a>
                </li>
                
                
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    

    
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    

    
    
        
            
                
                <li>
                    <a href="https://scozv.github.io/blog/zh/guide/2016/09/05/bolero-cumulative-update-on-sep-04-2016">
                      Bolero，累积更新说明（2016-09-04）
                      <small>Sep 05, 2016</small>
                    </a>
                </li>
                
                
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    

    
    
        
            
                
                <li>
                    <a href="https://scozv.github.io/blog/zh/guide/2016/08/22/scala-quick-tour-part-ii">
                      Scala函数编程（二）
                      <small>Aug 22, 2016</small>
                    </a>
                </li>
                
                
            
        
            
        
            
        
            
        
            
        
    

    
    
        
            
                
                <li>
                    <a href="https://scozv.github.io/blog/zh/guide/2016/08/21/scala-quick-tour-part-i">
                      Scala函数编程（一）
                      <small>Aug 21, 2016</small>
                    </a>
                </li>
                
                
            
        
            
        
            
        
            
        
            
        
    

    
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    

    
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
                
                <li>
                    <a href="https://scozv.github.io/blog/zh/pattern/2016/07/11/designing-cashier-microservice-with-ping-sdk">
                      使用Ping++设计可供集中收银的微服务
                      <small>Jul 11, 2016</small>
                    </a>
                </li>
                
                
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    

    
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    

    
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
                
                <li>
                    <a href="https://scozv.github.io/blog/zh/pattern/2016/05/05/a-low-coupling-architecture-of-the-web-solution-with-continuous-integration">
                      基于低耦合和持续集成的Web架构
                      <small>May 05, 2016</small>
                    </a>
                </li>
                
                
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    

    
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    
        
            
        
            
        
            
        
            
        
            
        
    


    </ul>


</div>





  <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_config = function () {
      this.page.url = 'https://scozv.github.io/blog/zh/guide/2016/07/27/bolero-a-restful-scaffold-with-scala';
      this.page.identifier = '/guide/2016/07/27/bolero-a-restful-scaffold-with-scala';
      this.page.title = 'Bolero——基于Scala、Play!和ReactiveMongo的RESTful代码模板';
    };
    (function() {
      var d = document;
      var s = d.createElement('script'); s.type = 'text/javascript'; s.async = true;
      s.src = 'https://scozv.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>







        </div>
      </div>

      <label for="sidebar-checkbox" class="sidebar-toggle"></label>
    

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
    <script src="https://scozv.github.io/blog/assets/katex/katex.min.js" type="text/javascript"></script>
    <script async src="https://scozv.github.io/blog/assets/katex/render.js" type="text/javascript"></script>
    


  <!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter43762899 = new Ya.Metrika({id:43762899, clickmap:true, trackLinks:true, accurateTrackBounce:true}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="//mc.yandex.ru/watch/43762899" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter -->




  </body>
</html>

